/******************************************************************************
Finite State Machine
Project: bal_fsm.dot
Description: bal_fsm

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.4
Generation date: 2023-07-19 21:28:20 +0200
Generated from: bal_fsm.dot
The finite state machine has:
  4 states
  5 transition functions
******************************************************************************/

#ifndef BAL_FSM_H
#define BAL_FSM_H

#include <stdlib.h>
#include <stdbool.h>
#include <inttypes.h>

#include "stm32l4xx_hal.h"
#include "../../../fenice_config.h"

// State data object
// By default set to void; override this typedef or load the proper
// header if you need
typedef void state_data_t;

// NOTHING SHALL BE CHANGED AFTER THIS LINE!

// List of states
typedef enum {
  STATE_INIT = 0,  
  STATE_OFF,  
  STATE_DISCHARGE,
  STATE_COOLDOWN,  
  NUM_STATES,
  NO_CHANGE
} bal_state_t;

typedef struct {
    // TODO: Add request sender
    // uint32_t timestamp;
    bool is_new;
    bal_state_t next_state;
} bal_fsm_transition_request;

typedef struct {
    bool is_s_pin_high; // Flag set to 1 when the LTC is actually discharging 0 otherwise
    uint32_t discharge_cells;
    uint32_t cycle_length;
    voltage_t target;
    uint16_t threshold;
} bal_fsm_params;

extern bal_fsm_transition_request set_bal_request;
extern bal_fsm_params bal_params;

// State human-readable names
extern const char * state_names[];

// State function and state transition prototypes
typedef bal_state_t state_func_t(state_data_t *data);
typedef void transition_func_t(state_data_t *data);

// State functions

// Function to be executed in state init
// valid return states: STATE_OFF
bal_state_t do_init(state_data_t *data);

// Function to be executed in state off
// valid return states: NO_CHANGE, STATE_OFF, STATE_DISCHARGE
bal_state_t do_off(state_data_t *data);

// Function to be executed in state discharge
// valid return states: NO_CHANGE, STATE_OFF, STATE_DISCHARGE, STATE_COOLDOWN
bal_state_t do_discharge(state_data_t *data);

// Function to be executed in state cooldown
// valid return states: NO_CHANGE, STATE_OFF, STATE_DISCHARGE, STATE_COOLDOWN
bal_state_t do_cooldown(state_data_t *data);


// List of state functions
extern state_func_t *const state_table[NUM_STATES];


// Transition functions
void init_to_off(state_data_t *data);
void start_discharge(state_data_t *data);
void stop_balancing(state_data_t *data);
void start_cooldown(state_data_t *data);
void cooldown_to_discharge(state_data_t *data);

// Table of transition functions
extern transition_func_t *const transition_table[NUM_STATES][NUM_STATES];

// state manager
bal_state_t run_state(bal_state_t cur_state, state_data_t *data);

/** @brief Run the FSM */
void fsm_run();
/**
 * @brief Get the state of the FSM
 * 
 * @return bal_state_t The current state of the FSM
 */
bal_state_t fsm_get_state();

/**
 * @brief Check if there are no cells to discharge
 * 
 * @return true If no cells needs to be discharged
 * @return false Otherwise
 */
bool bal_is_cells_empty();
/**
 * @brief Balancing timer output compare callback function
 * 
 * @param htim The timer handler instance
 */
void bal_oc_timer_handler(TIM_HandleTypeDef * htim);
/**
 * @brief Balancing timer interrupt callback function
 * 
 * @param htim The timer handler instance
 */
void bal_timers_handler(TIM_HandleTypeDef * htim);


#endif  // BAL_FSM_H
