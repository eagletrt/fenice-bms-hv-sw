/******************************************************************************
Finite State Machine
Project: bms_fsm.dot
Description: bms_hv_fsm

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.4
Generation date: 2023-07-05 07:57:19 +0200
Generated from: bms_fsm.dot
The finite state machine has:
  7 states
  9 transition functions
******************************************************************************/

#ifndef BMS_FSM_H
#define BMS_FSM_H

#include <stdlib.h>
#include <stdbool.h>

#include "tim.h"

// State data object
// By default set to void; override this typedef or load the proper
// header if you need
typedef void state_data_t;

// NOTHING SHALL BE CHANGED AFTER THIS LINE!

// List of states
typedef enum {
  STATE_INIT = 0,
  STATE_IDLE,
  STATE_FATAL_ERROR,
  STATE_WAIT_AIRN_CLOSE,
  STATE_WAIT_TS_PRECHARGE,
  STATE_WAIT_AIRP_CLOSE,
  STATE_TS_ON,
  NUM_STATES,
  NO_CHANGE
} bms_state_t;

typedef struct {
    // TODO: Add request sender
    // uint32_t timestamp;
    bool is_new;
    bms_state_t next_state;
} bms_fsm_transition_request;

extern bms_fsm_transition_request set_ts_request;

// State human-readable names
extern const char *state_names[];

// State function and state transition prototypes
typedef bms_state_t state_func_t(state_data_t *data);
typedef void transition_func_t(state_data_t *data);

// State functions

// Function to be executed in state init
// valid return states: STATE_IDLE
bms_state_t do_init(state_data_t *data);

// Function to be executed in state idle
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR, STATE_WAIT_AIRN_CLOSE
bms_state_t do_idle(state_data_t *data);

// Function to be executed in state fatal_error
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR
bms_state_t do_fatal_error(state_data_t *data);

// Function to be executed in state wait_airn_close
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR, STATE_WAIT_AIRN_CLOSE, STATE_WAIT_TS_PRECHARGE
bms_state_t do_wait_airn_close(state_data_t *data);

// Function to be executed in state wait_ts_precharge
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR, STATE_WAIT_TS_PRECHARGE, STATE_WAIT_AIRP_CLOSE
bms_state_t do_wait_ts_precharge(state_data_t *data);

// Function to be executed in state wait_airp_close
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR, STATE_WAIT_AIRP_CLOSE, STATE_TS_ON
bms_state_t do_wait_airp_close(state_data_t *data);

// Function to be executed in state ts_on
// valid return states: NO_CHANGE, STATE_IDLE, STATE_IDLE, STATE_FATAL_ERROR, STATE_TS_ON
bms_state_t do_ts_on(state_data_t *data);


// List of state functions
extern state_func_t *const state_table[NUM_STATES];


// Transition functions
void init_to_idle(state_data_t *data);
void set_fatal_error(state_data_t *data);
void close_airn(state_data_t *data);
void fatal_error_to_idle(state_data_t *data);
void set_ts_off(state_data_t *data);
void start_precharge(state_data_t *data);
void close_airp(state_data_t *data);
void set_ts_on(state_data_t *data);

// Table of transition functions
extern transition_func_t *const transition_table[NUM_STATES][NUM_STATES];

// state manager
bms_state_t run_state(bms_state_t cur_state, state_data_t *data);

/** @brief Run the FSM */
void fsm_run();
/**
 * @brief Get the state of the FSM
 * 
 * @return bms_state_t The current state of the FSM
 */
bms_state_t fsm_get_state();
/** @brief Set the led blinker pattern */
void bms_set_led_blinker();
/** @brief Run the led blinking pattern */
void bms_blink_led();
/** @Timer interrupt callback function */
void _bms_handle_tim_oc_irq(TIM_HandleTypeDef *htim);


#endif
