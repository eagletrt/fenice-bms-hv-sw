/******************************************************************************
Finite State Machine
Project: bms_fsm.dot
Description: bms_hv_fsm

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.4
Generation date: 2023-07-04 15:25:30 +0200
Generated from: bms_fsm.dot
The finite state machine has:
  8 states
  18 transition functions
******************************************************************************/

#ifndef BMS_FSM_H
#define BMS_FSM_H
#include <stdlib.h>

// State data object
// By default set to void; override this typedef or load the proper
// header if you need
typedef void state_data_t;

// NOTHING SHALL BE CHANGED AFTER THIS LINE!

// List of states
typedef enum {
  STATE_INIT = 0,  
  STATE_IDLE,  
  STATE_FATAL_ERROR,  
  STATE_WAIT_AIRN_CLOSE,  
  STATE_WAIT_TS_PRECHARGE,  
  STATE_WAIT_AIRP_CLOSE,  
  STATE_WAIT_TS_PRECHARLSGE,  
  STATE_TS_ON,  
  NUM_STATES,
  NO_CHANGE
} state_t;

// State human-readable names
extern const char *state_names[];

// State function and state transition prototypes
typedef state_t state_func_t(state_data_t *data);
typedef void transition_func_t(state_data_t *data);

// State functions

// Function to be executed in state init
// valid return states: STATE_IDLE
state_t do_init(state_data_t *data);

// Function to be executed in state idle
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR, STATE_WAIT_AIRN_CLOSE
state_t do_idle(state_data_t *data);

// Function to be executed in state fatal_error
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR
state_t do_fatal_error(state_data_t *data);

// Function to be executed in state wait_airn_close
// valid return states: NO_CHANGE, STATE_FATAL_ERROR, STATE_WAIT_AIRN_CLOSE, STATE_WAIT_TS_PRECHARGE
state_t do_wait_airn_close(state_data_t *data);

// Function to be executed in state wait_ts_precharge
// valid return states: STATE_FATAL_ERROR, STATE_WAIT_AIRP_CLOSE, STATE_WAIT_TS_PRECHARLSGE
state_t do_wait_ts_precharge(state_data_t *data);

// Function to be executed in state wait_airp_close
// valid return states: NO_CHANGE, STATE_FATAL_ERROR, STATE_WAIT_AIRP_CLOSE, STATE_TS_ON
state_t do_wait_airp_close(state_data_t *data);

// Function to be executed in state wait_ts_precharlsge
// valid return states: NO_CHANGE
state_t do_wait_ts_precharlsge(state_data_t *data);

// Function to be executed in state ts_on
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR, STATE_TS_ON
state_t do_ts_on(state_data_t *data);


// List of state functions
extern state_func_t *const state_table[NUM_STATES];


// Transition functions
void init_to_idle(state_data_t *data);
void stay_idle(state_data_t *data);
void set_idle_fatal_error(state_data_t *data);
void close_airn(state_data_t *data);
void fatal_error_to_idle(state_data_t *data);
void stay_fatal_error(state_data_t *data);
void set_airn_fatal_error(state_data_t *data);
void check_airn_close(state_data_t *data);
void start_precharge(state_data_t *data);
void set_precharge_fatal_error(state_data_t *data);
void close_airp(state_data_t *data);
void stay_wait_ts_precharge(state_data_t *data);
void set_airp_fatal_error(state_data_t *data);
void stay_wait_airp_close(state_data_t *data);
void set_ts_on(state_data_t *data);
void ts_on_to_idle(state_data_t *data);
void set_ts_fatal_error(state_data_t *data);
void stay_ts_on(state_data_t *data);

// Table of transition functions
extern transition_func_t *const transition_table[NUM_STATES][NUM_STATES];

// state manager
state_t run_state(state_t cur_state, state_data_t *data);

#endif
