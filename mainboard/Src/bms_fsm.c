/******************************************************************************
Finite State Machine
Project: bms_fsm.dot
Description: bms_hv_fsm

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.4
Generation date: 2023-07-04 15:25:30 +0200
Generated from: bms_fsm.dot
The finite state machine has:
  8 states
  18 transition functions
******************************************************************************/

#include "bms_fsm.h"

#include <string.h>

#include "can_comm.h"
#include "primary/primary_network.h"
#include "cli_bms.h"
#include "feedback.h"
#include "pack/pack.h"

// SEARCH FOR Your Code Here FOR CODE INSERTION POINTS!

// GLOBALS
// State human-readable names
const char *state_names[] = {"init", "idle", "fatal_error", "wait_airn_close", "wait_ts_precharge", "wait_airp_close", "wait_ts_precharlsge", "ts_on"};
char debug_msg[100] = { 0 };

// List of state functions
state_func_t *const state_table[NUM_STATES] = {
  do_init,                // in state init
  do_idle,                // in state idle
  do_fatal_error,         // in state fatal_error
  do_wait_airn_close,     // in state wait_airn_close
  do_wait_ts_precharge,   // in state wait_ts_precharge
  do_wait_airp_close,     // in state wait_airp_close
  do_wait_ts_precharlsge, // in state wait_ts_precharlsge
  do_ts_on,               // in state ts_on
};

// Table of transition functions
transition_func_t *const transition_table[NUM_STATES][NUM_STATES] = {
  /* states:                 init                     , idle                     , fatal_error              , wait_airn_close          , wait_ts_precharge        , wait_airp_close          , wait_ts_precharlsge      , ts_on                     */
  /* init                */ {NULL                     , init_to_idle             , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     }, 
  /* idle                */ {NULL                     , stay_idle                , set_idle_fatal_error     , close_airn               , NULL                     , NULL                     , NULL                     , NULL                     }, 
  /* fatal_error         */ {NULL                     , fatal_error_to_idle      , stay_fatal_error         , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     }, 
  /* wait_airn_close     */ {NULL                     , NULL                     , set_airn_fatal_error     , check_airn_close         , start_precharge          , NULL                     , NULL                     , NULL                     }, 
  /* wait_ts_precharge   */ {NULL                     , NULL                     , set_precharge_fatal_error, NULL                     , NULL                     , close_airp               , stay_wait_ts_precharge   , NULL                     }, 
  /* wait_airp_close     */ {NULL                     , NULL                     , set_airp_fatal_error     , NULL                     , NULL                     , stay_wait_airp_close     , NULL                     , set_ts_on                }, 
  /* wait_ts_precharlsge */ {NULL                     , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     , NULL                     }, 
  /* ts_on               */ {NULL                     , ts_on_to_idle            , set_ts_fatal_error       , NULL                     , NULL                     , NULL                     , NULL                     , stay_ts_on               }, 
};

/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state init
// valid return states: STATE_IDLE
state_t do_init(state_data_t *data) {
  state_t next_state = STATE_IDLE;
  
  cli_bms_debug("[FSM] In state init", 19);
  /* Your Code Here */

  switch (next_state) {
    case STATE_IDLE:
      break;
    default:
      sprintf(debug_msg, "[FSM] Cannot pass from init to %s, remaining in this state", state_names[next_state]);
      cli_bms_debug(debug_msg, strlen(debug_msg));
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state idle
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR, STATE_WAIT_AIRN_CLOSE
state_t do_idle(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  cli_bms_debug("[FSM] In state idle", 19);
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
    case STATE_IDLE:
    case STATE_FATAL_ERROR:
    case STATE_WAIT_AIRN_CLOSE:
      break;
    default:
      sprintf(debug_msg, "[FSM] Cannot pass from idle to %s, remaining in this state", state_names[next_state]);
      cli_bms_debug(debug_msg, strlen(debug_msg));
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state fatal_error
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR
state_t do_fatal_error(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  cli_bms_debug("[FSM] In state fatal_error", 26);
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
    case STATE_IDLE:
    case STATE_FATAL_ERROR:
      break;
    default:
      sprintf(debug_msg, "[FSM] Cannot pass from fatal_error to %s, remaining in this state", state_names[next_state]);
      cli_bms_debug(debug_msg, strlen(debug_msg));
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state wait_airn_close
// valid return states: NO_CHANGE, STATE_FATAL_ERROR, STATE_WAIT_AIRN_CLOSE, STATE_WAIT_TS_PRECHARGE
state_t do_wait_airn_close(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  cli_bms_debug("[FSM] In state wait_airn_close", 30);
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
    case STATE_FATAL_ERROR:
    case STATE_WAIT_AIRN_CLOSE:
    case STATE_WAIT_TS_PRECHARGE:
      break;
    default:
      sprintf(debug_msg, "[FSM] Cannot pass from wait_airn_close to %s, remaining in this state", state_names[next_state]);
      cli_bms_debug(debug_msg, strlen(debug_msg));
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state wait_ts_precharge
// valid return states: STATE_FATAL_ERROR, STATE_WAIT_AIRP_CLOSE, STATE_WAIT_TS_PRECHARLSGE
state_t do_wait_ts_precharge(state_data_t *data) {
  state_t next_state = STATE_FATAL_ERROR;
  
  cli_bms_debug("[FSM] In state wait_ts_precharge", 32);
  /* Your Code Here */
  
  switch (next_state) {
    case STATE_FATAL_ERROR:
    case STATE_WAIT_AIRP_CLOSE:
    case STATE_WAIT_TS_PRECHARLSGE:
      break;
    default:
      sprintf(debug_msg, "[FSM] Cannot pass from wait_ts_precharge to %s, remaining in this state", state_names[next_state]);
      cli_bms_debug(debug_msg, strlen(debug_msg));
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state wait_airp_close
// valid return states: NO_CHANGE, STATE_FATAL_ERROR, STATE_WAIT_AIRP_CLOSE, STATE_TS_ON
state_t do_wait_airp_close(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  cli_bms_debug("[FSM] In state wait_airp_close", 30);
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
    case STATE_FATAL_ERROR:
    case STATE_WAIT_AIRP_CLOSE:
    case STATE_TS_ON:
      break;
    default:
      sprintf(debug_msg, "[FSM] Cannot pass from wait_airp_close to %s, remaining in this state", state_names[next_state]);
      cli_bms_debug(debug_msg, strlen(debug_msg));
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state wait_ts_precharlsge
// valid return states: NO_CHANGE
state_t do_wait_ts_precharlsge(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  cli_bms_debug("[FSM] In state wait_ts_precharlsge", 34);
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
      break;
    default:
      sprintf(debug_msg, "[FSM] Cannot pass from wait_ts_precharlsge to %s, remaining in this state", state_names[next_state]);
      cli_bms_debug(debug_msg, strlen(debug_msg));
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state ts_on
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR, STATE_TS_ON
state_t do_ts_on(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  cli_bms_debug("[FSM] In state ts_on", 20);
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
    case STATE_IDLE:
    case STATE_FATAL_ERROR:
    case STATE_TS_ON:
      break;
    default:
      sprintf(debug_msg, "[FSM] Cannot pass from ts_on to %s, remaining in this state", state_names[next_state]);
      cli_bms_debug(debug_msg, strlen(debug_msg));
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


/*  _____                    _ _   _              
 * |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __   
 *   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
 *   | || | | (_| | | | \__ \ | |_| | (_) | | | | 
 *   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_| 
 *                                                
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */    
                                         
// This function is called in 1 transition:
// 1. from init to idle
void init_to_idle(state_data_t *data) {
  cli_bms_debug("[FSM] State transition init_to_idle", 35);

  // Send status via can
  can_car_send(PRIMARY_TS_STATUS_FRAME_ID);

  // Set pack pins
  pack_set_default_off(0);
  pack_set_fault(BMS_FAULT_OFF_VALUE);

  // Start feedback check timer
  _start_fb_check_timer();

  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from idle to idle
void stay_idle(state_data_t *data) {
  cli_bms_debug("[FSM] State transition stay_idle", 32);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from idle to fatal_error
void set_idle_fatal_error(state_data_t *data) {
  cli_bms_debug("[FSM] State transition set_idle_fatal_error", 43);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from idle to wait_airn_close
void close_airn(state_data_t *data) {
  cli_bms_debug("[FSM] State transition close_airn", 33);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from fatal_error to idle
void fatal_error_to_idle(state_data_t *data) {
  cli_bms_debug("[FSM] State transition fatal_error_to_idle", 42);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from fatal_error to fatal_error
void stay_fatal_error(state_data_t *data) {
  cli_bms_debug("[FSM] State transition stay_fatal_error", 39);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from wait_airn_close to fatal_error
void set_airn_fatal_error(state_data_t *data) {
  cli_bms_debug("[FSM] State transition set_airn_fatal_error", 43);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from wait_airn_close to wait_airn_close
void check_airn_close(state_data_t *data) {
  cli_bms_debug("[FSM] State transition check_airn_close", 39);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from wait_airn_close to wait_ts_precharge
void start_precharge(state_data_t *data) {
  cli_bms_debug("[FSM] State transition start_precharge", 38);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from wait_ts_precharge to fatal_error
void set_precharge_fatal_error(state_data_t *data) {
  cli_bms_debug("[FSM] State transition set_precharge_fatal_error", 48);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from wait_ts_precharge to wait_airp_close
void close_airp(state_data_t *data) {
  cli_bms_debug("[FSM] State transition close_airp", 33);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from wait_ts_precharge to wait_ts_precharlsge
void stay_wait_ts_precharge(state_data_t *data) {
  cli_bms_debug("[FSM] State transition stay_wait_ts_precharge", 45);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from wait_airp_close to fatal_error
void set_airp_fatal_error(state_data_t *data) {
  cli_bms_debug("[FSM] State transition set_airp_fatal_error", 43);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from wait_airp_close to wait_airp_close
void stay_wait_airp_close(state_data_t *data) {
  cli_bms_debug("[FSM] State transition stay_wait_airp_close", 43);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from wait_airp_close to ts_on
void set_ts_on(state_data_t *data) {
  cli_bms_debug("[FSM] State transition set_ts_on", 32);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from ts_on to idle
void ts_on_to_idle(state_data_t *data) {
  cli_bms_debug("[FSM] State transition ts_on_to_idle", 36);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from ts_on to fatal_error
void set_ts_fatal_error(state_data_t *data) {
  cli_bms_debug("[FSM] State transition set_ts_fatal_error", 41);
  /* Your Code Here */
}

// This function is called in 1 transition:
// 1. from ts_on to ts_on
void stay_ts_on(state_data_t *data) {
  cli_bms_debug("[FSM] State transition stay_ts_on", 33);
  /* Your Code Here */
}


/*  ____  _        _        
 * / ___|| |_ __ _| |_ ___  
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/ 
 * |____/ \__\__,_|\__\___| 
 *                          
 *                                              
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |   
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
 *                              |___/           
 */

state_t run_state(state_t cur_state, state_data_t *data) {
  state_t new_state = state_table[cur_state](data);
  if (new_state == NO_CHANGE) new_state = cur_state;
  transition_func_t *transition = transition_table[cur_state][new_state];
  if (transition)
    transition(data);
  return new_state;
};

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
  state_t cur_state = STATE_INIT;
  openlog("SM", LOG_PID | LOG_PERROR, LOG_USER);
  syslog(LOG_INFO, "Starting SM");
  do {
    cur_state = run_state(cur_state, NULL);
    sleep(1);
  } while (cur_state != STATE_WAIT_TS_PRECHARLSGE);
  run_state(cur_state, NULL);
  return 0;
}
#endif
